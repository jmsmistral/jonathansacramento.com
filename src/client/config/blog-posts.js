
  const blogPosts = [{"id":1,"route":"improve-your-postgresql-workflow-with-vim-and-dbext","title":"Improve your PostgreSQL workflow with vim and dbext","content":"<p>If you&#39;ve worked with PostgreSQL in the past using the <a href=\"http://www.postgresql.org/docs/current/static/app-psql.html\">psql</a> client you might have noticed that, although powerful, it&#39;s not a tool geared for writing (or reading) complex multi-line queries, or following a <strong>&#39;write-execute-refine&#39; workflow</strong>; that is, where you write some code, execute it, refine the code based on results... So, let&#39;s say I write some SQL code in vim, and I want to run it to see if it works. I would have to copy the block of code to a new buffer, save as it as a file, switch to psql, type <code>\\i &lt;path-to-file&gt;</code>, hit Enter and wait for the results (... oh, and now you have a new file to maintain temporarily).</p>\n<blockquote>\n<h2 id=\"wouldnt-it-be-nice-to-be-able-to-write-execute-and-view-the-results-from-within-vim\">Wouldn&#39;t it be nice to be able to write, execute, and view the results from within vim?</h2>\n</blockquote>\n<p>We can definitely streamline this workflow, and reduce it to one or two keystrokes from within vim (because god forbid we move our fingers away from the &#39;hjkl&#39; position!).</p>\n<p><a href=\"https://github.com/vim-scripts/dbext.vim\">dbext</a> is a vim plugin that aims to do exactly that (credit to the author Peter Bagyinszki)! Don&#39;t be put-off by the poorly presented <a href=\"https://github.com/vim-scripts/dbext.vim\">Github</a> or <a href=\"http://www.vim.org/scripts/script.php?script_id=356\">Vim scripts</a> page - the plugin comes with a helpful tutorial (described below) that covers what you need to know. Here, I will show you what I had to do to get started using dbext.</p>\n<h2 id=\"what-you-need\">What you need</h2>\n<p>You need to have <strong>vim 7+</strong>, and the <strong>psql</strong> client installed locally. You&#39;ll also need access to a <strong>PostgreSQL</strong> server.</p>\n<h2 id=\"download-and-configure-dbext\">Download and configure dbext</h2>\n<p>I use the <a href=\"https://github.com/tpope/vim-pathogen\">Pathogen</a> vim plugin to easily install other plugins and run-time files. If you do too, then just navigate to the <code>~/.vim/bundle/</code> folder in your home directory and clone the dbext Github repository.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> <span class=\"hljs-built_in\">cd</span> ~/.vim/bundle/</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> git <span class=\"hljs-built_in\">clone</span> https://github.com/vim-scripts/dbext.vim</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> ls</span>\ndbext.vim/</code></pre>\n<p><strong>That&#39;s it - installed!</strong>&nbsp;&nbsp;&nbsp;ðŸŽ‰</p>\n<p>dbext works by relating every vim buffer to a database connection profile that we define in our <code>.vimrc</code>. A connection profile describes a set of parameters needed to connect to a database, such as username, host, port, database name etc. We can define various profiles, and also define a default profile to use whenever a new buffer is opened in vim. Open your <code>.vimrc</code> file and enter the following two lines, making sure you substitute your values for host, port, dbname, and user (for PostgreSQL, leave the type as &#39;PGSQL&#39;). In the example below, we are connecting to a database called <strong>&#39;jms&#39;</strong>, as user <strong>&#39;jms&#39;</strong>, on a server running on the same machine <strong>&#39;localhost&#39;</strong> via port <strong>5433</strong>.</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" Each profile has the form:\n\"</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile<span class=\"hljs-number\">_</span><span class=\"hljs-string\">'profilename'</span> = <span class=\"hljs-string\">'var=value:var=value:...'</span>\n<span class=\"hljs-keyword\">let</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile<span class=\"hljs-number\">_p</span>sql = <span class=\"hljs-string\">'type=PGSQL:host=localhost:port=5433:dbname=jms:user=jms'</span>\n<span class=\"hljs-keyword\">let</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile = <span class=\"hljs-string\">'psql'</span></code></pre>\n<p><strong>Notice that we&#39;re not entering our password</strong> - this is because the psql client will either ask us for a password when we connect, or looks for a <code>.pgpass</code> file in our home directory. I recommend having a <code>.pgpass</code> file. This file typically has a single line of the form: <code>hostname:port:database:username:password</code></p>\n<h2 id=\"running-queries\">Running queries</h2>\n<p>Now that we have dbext installed, let&#39;s see what we can do with it! I do recommend taking some time to read over the tutorial that comes with dbext by typing the following in vim:</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-selector-pseudo\">:h</span> <span class=\"hljs-selector-tag\">dbext-tutorial</span></code></pre>\n<p>Now let&#39;s start running some code! Let&#39;s get some data from a table in our database.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> staging.customer;</code></pre>\n<p><strong>We can run this either in normal mode or visual mode</strong>. In normal mode, simply move the cursor somewhere within the query (in the example above this would be between the <strong>&#39;s&#39;</strong> or <strong>&#39;;&#39;</strong>, inclusive) and type the following, replacing <code>\\</code> with your leader character.</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\\se</span></code></pre>\n<p><strong>This will bring up the results buffer</strong> - a read-only split window displaying the results for the executed statement(s); To focus on this press <code>Ctrl + w</code> twice in quick succession. You can navigate the results buffer as you would any other vim buffer. To close the results, first switch to it, and then press <code>q</code>. Additionally, if the results split is too small, you can even it out by pressing <code>Ctrl + w</code> once, followed by <code>=</code>. Alternatively, you can type <code>:res +5</code> or <code>:res -5</code> to make the split window bigger or smaller by 5 rows.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-1.png\" alt=\"\"></p>\n<p>If we had multiple queries and only wanted to run one, or a couple of them, we could enter <strong>visual mode</strong> to select them (<code>Shift + v</code> followed by <code>j</code> or <code>k</code> to select rows down or up) and again type <code>\\se</code>, as before.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-2.png\" alt=\"\"></p>\n<p><strong>Isn&#39;t that exciting?!!</strong>&nbsp;&nbsp;ðŸ¤“ That&#39;s just a taster - I&#39;ve added a small reference of dbext commands at the end of this post. Before that, there&#39;s a cool feature you&#39;ll love... <strong><em>auto-completion</em></strong>.</p>\n<h2 id=\"auto-completion\">Auto-completion</h2>\n<p>When working with a large number of tables/views, it can be hard to remember all their names. dbext can help-out with a pop-up menu of potential matches. This functionality does require the following to be done:</p>\n<ul>\n<li>You must be working from a saved file ending in .sql</li>\n<li>Populate the vim dictionary using either of the following commands <code>DBCompleteTables</code>, <code>DBCompleteViews</code>, or <code>DBCompleteProcedures</code></li>\n</ul>\n<p>To avoid having to type a <code>DBComplete*</code> command whenever I start a new buffer, I added this to my <code>.vimrc</code> (this runs the given command once all plugins have been loaded):</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-attribute\">autocmd</span> VimEnter * DBCompleteTables</code></pre>\n<p>Once that&#39;s done and dusted, start typing a <code>SELECT</code> statement. After the <code>FROM</code> keyword, press <code>Ctrl + x</code> and <code>Ctrl + o</code> in quick succession, this will bring up a menu showing all matching tables. So, if we had started typing the name of the table, and then brought-up the menu, it would filter only tables matching what we&#39;ve typed so far. Scroll up and down the menu with <code>Ctrl + n</code> and <code>Ctrl + p</code>.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-3.png\" alt=\"\"></p>\n<h2 id=\"quick-reference\">Quick Reference</h2>\n<h3 id=\"code-execution\">Code Execution</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-comment\">\" Execute code in normal or visual mode. (s)ql (e)xecute</span>\n\\<span class=\"hljs-keyword\">se</span>\n\n<span class=\"hljs-comment\">\" Execute just the current line. (s)ql (e)xecute (l)ine</span>\n\\sel</code></pre>\n<h3 id=\"select-from-tables\">Select from Tables</h3>\n<pre><code class=\"hljs language-vim\">\" <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span> (s)ql (t)able\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\st\n\n\"</span> <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span>, <span class=\"hljs-keyword\">prompt</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">rows</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">return</span>  (s)ql (T)able\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\sT\n\n\"</span> <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span>, <span class=\"hljs-keyword\">prompt</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">WHERE</span> clause  (s)ql (t)able (w)here\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\stw</span></code></pre>\n<h3 id=\"describe-objects\">Describe Objects</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" Describe table (s)ql (d)escribe (t)able\n\"</span> Place cursor over table name, <span class=\"hljs-keyword\">or</span> visual mode select schema &amp; table name\n\\sdt\n\n<span class=\"hljs-string\">\" Describe procedure (s)ql (d)escribe (p)rocedure\n\"</span> Place cursor over <span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">name</span>, <span class=\"hljs-title\">or</span> <span class=\"hljs-title\">visual</span> <span class=\"hljs-title\">mode</span> <span class=\"hljs-title\">select</span> <span class=\"hljs-title\">schema</span> &amp; <span class=\"hljs-title\">procedure</span> <span class=\"hljs-title\">name</span>\n\\<span class=\"hljs-title\">sdp</span>\n\n\" <span class=\"hljs-title\">Describe</span> <span class=\"hljs-title\">procedure</span> <span class=\"hljs-params\">(s)</span><span class=\"hljs-title\">ql</span> <span class=\"hljs-params\">(d)</span><span class=\"hljs-title\">escribe</span> <span class=\"hljs-params\">(v)</span><span class=\"hljs-title\">iew</span>\n\" <span class=\"hljs-title\">Place</span> <span class=\"hljs-title\">cursor</span> <span class=\"hljs-title\">over</span> <span class=\"hljs-title\">view</span> <span class=\"hljs-title\">name</span>, <span class=\"hljs-title\">or</span> <span class=\"hljs-title\">visual</span> <span class=\"hljs-title\">mode</span> <span class=\"hljs-title\">select</span> <span class=\"hljs-title\">schema</span> &amp; <span class=\"hljs-title\">view</span> <span class=\"hljs-title\">name</span>\n\\<span class=\"hljs-title\">sdv</span></span></code></pre>\n<h3 id=\"listing-objects\">Listing Objects</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" List tables in database (s)ql (l)ist (t)able\n\"</span> Prompts <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">to</span> match tables <span class=\"hljs-keyword\">by</span> <span class=\"hljs-built_in\">name</span>\n\\slt\n\n<span class=\"hljs-string\">\" Same but for procedures\n\\slp\n\n\"</span> Same <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">for</span> views\n\\slv\n\n<span class=\"hljs-string\">\" Get list of table columns in paste buffer (s)ql (l)ist (c)olumns\n\"</span> Place cursor <span class=\"hljs-keyword\">over</span> table <span class=\"hljs-built_in\">name</span>. Recognises schemas <span class=\"hljs-keyword\">without</span> visual mode selection\n<span class=\"hljs-string\">\" Prompts for alias prefix to be added\n\\slc</span></code></pre>\n<h3 id=\"results-buffer-run-inside-results-buffer\">Results Buffer (run inside results buffer)</h3>\n<pre><code class=\"hljs language-vim\">\" Re-<span class=\"hljs-keyword\">run</span> <span class=\"hljs-keyword\">query</span> that generated current results buffer\n<span class=\"hljs-built_in\">R</span>\n\n\" <span class=\"hljs-keyword\">Close</span> results buffer\n<span class=\"hljs-built_in\">q</span></code></pre>\n<h3 id=\"command-history\">Command History</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" List recently executed statements \n\"</span> Press RETURN key <span class=\"hljs-keyword\">on</span> selected statement <span class=\"hljs-keyword\">to</span> re-execute\n\\sh</code></pre>\n","date":"January 22, 2016"},{"id":2,"route":"clean-sql","title":"Clean SQL","content":"<p>I analyse a lot of data daily, much of the time using SQL. As a language, SQL is relatively simple and self-contained, and newcomers usually don&#39;t take long to start writing code that works (after learning to think declaratively!). Like other languages, <strong>SQL can be written in a way that reads like poetry</strong>, where the logic of the query is clear to anyone who reads it. <strong>Often, however, reading someone else&#39;s SQL code is a very <a href=\"http://www.urbandictionary.com/define.php?term=clusterfuck\">unpleasant experience</a></strong>... and although it&#39;s usually code written by rookies, &#39;pro&#39; code can be just as painful at times.</p>\n<p>It seems that newcomers to SQL don&#39;t think it&#39;s important to write code that is easy to read and understand by others. Instead they focus solely on getting the data output needed. On the other hand, I feel <strong>experienced coders tend to over-engineer the formatting of the code</strong> (think <em>over alignment</em>).</p>\n<p>This has prompted me to write this post, which will serve as a living document of what I feel is the best way to write SQL code...</p>\n<h2 id=\"why-clean-code\">Why clean code?</h2>\n<p>In any project where code is written, whether for data analysis or a complex app, <strong>the compounding effects of messy code affects productivity and costs</strong>. Bad code slows down the pace of the team, making any change less and less trivial as time progresses. Unfortunately, the pace of projects, and the pressure to produce results urges the team to add more bad code. Eventually, you end-up with a colossal pile of ðŸ’© that shatters when touched.</p>\n<blockquote>\n<h2 id=\"code-is-written-once-and-read-many-times-so-consistently-write-clear-human-readable-code\">Code is written once, and read many times. So consistently write clear, human-readable code.</h2>\n</blockquote>\n<h2 id=\"example-of-bad-code\">Example of bad code</h2>\n<p>Before I start looking at how to write clean SQL, let&#39;s explore the motivation behind this... What do you think is wrong in this first example below (sanitzed real-world example written in TSQL)?</p>\n<pre><code class=\"hljs language-sql\">SELECT\n    c<span class=\"hljs-selector-class\">.Date</span>\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span>,\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.description</span>,\n    e0<span class=\"hljs-selector-class\">.Classification</span>,\n    ExampleFlag = <span class=\"hljs-number\">1</span>,\n    FutureFcstMethod = CASE WHEN c<span class=\"hljs-selector-class\">.Discount</span> NOT NULL THEN <span class=\"hljs-string\">'Mthd1'</span>\n        WHEN (<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Uplift</span> IS NOT NULL AND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Forecast</span> IS NOT NULL) THEN <span class=\"hljs-string\">'Mthd2'</span> END,\n    SUM(IIF(e0.Flag=<span class=\"hljs-number\">0</span>, cost, NULL))/NULLIF(SUM(IIF(e0.Flag=<span class=\"hljs-number\">0</span>, sales, NULL)),<span class=\"hljs-number\">0</span>) as Rate\nFROM Dim<span class=\"hljs-selector-class\">.Product</span> <span class=\"hljs-selector-tag\">a</span>\nLEFT JOIN fst<span class=\"hljs-selector-class\">.ProductClass</span> e0 ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = e0<span class=\"hljs-selector-class\">.ProductKey</span>\nLEFT JOIN fact<span class=\"hljs-selector-class\">.Discounts</span> c ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = c<span class=\"hljs-selector-class\">.ProductKey</span>\nINNER JOIN fst<span class=\"hljs-selector-class\">.A_Final_Product_Analysis</span> <span class=\"hljs-selector-tag\">b</span> ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.ProductKey</span>\nAND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.TransDate</span> &lt; c<span class=\"hljs-selector-class\">.Date</span>\nWHERE <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.productKey</span> NOT IN (<span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">5678</span>, <span class=\"hljs-number\">90123</span>)\nAND e0<span class=\"hljs-selector-class\">.Classification</span> IN (<span class=\"hljs-string\">'A'</span>, <span class=\"hljs-string\">'BC'</span>, <span class=\"hljs-string\">'A21'</span>)\nAND c<span class=\"hljs-selector-class\">.Discount</span> &gt; <span class=\"hljs-number\">0</span>\nGROUP BY\n    c<span class=\"hljs-selector-class\">.Date</span>\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.Product</span>,\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.description</span>,\n    e0<span class=\"hljs-selector-class\">.Classification</span>,\n    CASE WHEN c<span class=\"hljs-selector-class\">.Discount</span> NOT NULL THEN <span class=\"hljs-string\">'Mthd1'</span>\n        WHEN (<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Uplift</span> IS NOT NULL AND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Forecast</span> IS NOT NULL) THEN <span class=\"hljs-string\">'Mthd2'</span> END</code></pre>\n<p>That&#39;s right... <strong><em>everything</em></strong>.</p>\n<p>The code is <strong>densely packed</strong>, <strong>mis-aligned</strong>, and uses <strong>obscure naming</strong>... it&#39;s hard to glean any information from it.</p>\n<h2 id=\"clean-code-rules\">Clean code rules</h2>\n<p>Most experienced programmers agree with a version of these rules. For an in-depth analysis of how to write clean code, I really recommend reading Robert Martin&#39;s <a href=\"https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882\">Clean Code</a>.</p>\n<h3 id=\"naming\">Naming</h3>\n<ul>\n<li>Name objects in a way that tells the purpose of the object - calling a field <code>acc_111</code> doesn&#39;t tell us anything. A rule of thumb is the ability to easily pronounce the name.</li>\n<li>Use <strong>camelCase</strong> for fields and <strong>TitleCase</strong> for tables - call a table <code>SalesTransactionHistory</code> instead of <code>sales_transaction_history</code>, and a field <code>totalRevenue</code> instead of <code>total_revenue</code>.</li>\n<li>Functions or stored procedures should start with a verb that tells what it does - <code>getSalesForecast</code> instead of <code>forecast</code>. Do not add any prefix like <code>sp_</code> or <code>fn_</code> or any other Hungarian Notation.</li>\n<li>Give consistent, meaningful aliases to joined tables in a query - <code>a</code>, <code>b</code>, <code>c</code> is just confusing. Instead, use <code>prd</code> for a product dimension table, or <code>sales</code> for a sales fact table.</li>\n</ul>\n<h3 id=\"formatting\">Formatting</h3>\n<ul>\n<li><strong>Don&#39;t capitalise SQL clauses</strong> like select, from, ... capital letters are hard on the eyes, and make the code look more dense.</li>\n<li>In general, <strong>structure your code vertically</strong> rather than horizontally. For example, list fields vertically in a select. If you want to be strict about it, any line should not exceed more than 80 characters in length.</li>\n<li><strong>Do not horizontally-align code</strong>. Code that has been overly aligned in this way creates too much separation between parts of the code that correspond to each other, drawing attention away from that relevant correspondence. For example, separating fields and data types in a create table statement draws you to look at the list of field names and not their data types.</li>\n<li>Lists of fields, where conditions, and tables after a from statement, must:<ul>\n<li>start on a new line</li>\n<li>have one level of indentation</li>\n<li>be left-aligned</li>\n</ul>\n</li>\n<li>Joins are clear when formatted as below, with the join clause double indented, and the joined fields triple indented.</li>\n</ul>\n<pre><code class=\"hljs language-sql\">select\n     tbl1<span class=\"hljs-selector-class\">.field1</span>\n    ,tbl1<span class=\"hljs-selector-class\">.field2</span>\nfrom\n    table1 tb1\n        inner join\n    table2 tb2\n            on  tb1<span class=\"hljs-selector-class\">.field1</span> = tb2<span class=\"hljs-selector-class\">.field1</span>\n            and tb1<span class=\"hljs-selector-class\">.field2</span> = tb2<span class=\"hljs-selector-class\">.field2</span>\n        <span class=\"hljs-attribute\">left</span> join\n    table3 tb3\n            on ...</code></pre>\n<h3 id=\"comments\">Comments</h3>\n<ul>\n<li><strong>Use comments sparingly</strong> - a comment is only needed when the code is unclear enough that it needs to be explained. Messy code won&#39;t be made better with the addition of comments.</li>\n<li>In writing a comment, restrict it to stating the general purpose of a block of code in the most concise manner possible.</li>\n<li>Never leave commented code co-existing with live code.</li>\n</ul>\n<h3 id=\"queries-functions--procedures\">Queries, Functions &amp; Procedures</h3>\n<ul>\n<li>If the logic in a single query is hard to understand, then it is probably doing too much at once. Separate the logic into multiple steps using either CTEs or temporary tables.</li>\n<li>Each function or procedure should do one thing, do it well, and do it only - if it&#39;s doing too much, then split the logic into more than one function or procedure.</li>\n</ul>\n<h2 id=\"examples-of-clean-code\">Examples of clean code</h2>\n<p>It&#39;s easier to see how to write clean SQL code by seeing some examples.</p>\n<h3 id=\"select-statements\">Select statements</h3>\n<pre><code class=\"hljs language-sql\">select\n     rev<span class=\"hljs-selector-class\">.accountKey</span>\n    ,rev<span class=\"hljs-selector-class\">.revenueType</span>\n    ,coalesce(cus<span class=\"hljs-selector-class\">.indexedChurnDate</span>, <span class=\"hljs-number\">0</span>) - coalesce(cus<span class=\"hljs-selector-class\">.indexedGrossAddDate</span>, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span> as totalMonths\n    ,sum(coalesce(rev<span class=\"hljs-selector-class\">.revenueValue</span>, <span class=\"hljs-number\">0</span>)) as revenueValue\nfrom\n    fact<span class=\"hljs-selector-class\">.Revenue</span> rev\n        inner join\n    dim<span class=\"hljs-selector-class\">.Customer</span> cus\n            on rev<span class=\"hljs-selector-class\">.accountKey</span> = cus<span class=\"hljs-selector-class\">.accountKey</span>\nwhere\n    rev<span class=\"hljs-selector-class\">.accountKey</span> <span class=\"hljs-keyword\">in</span> (select distinct accountKey from shortLifeCustomers)\ngroup by\n     rev<span class=\"hljs-selector-class\">.accountKey</span>\n    ,rev<span class=\"hljs-selector-class\">.revenueType</span>\n    ,totalMonths</code></pre>\n<h3 id=\"ctes-common-table-expressions\">CTEs (Common Table Expressions)</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">with</span> NewProducts <span class=\"hljs-keyword\">as</span> (\n    <span class=\"hljs-keyword\">select</span>\n        productKey\n    <span class=\"hljs-keyword\">from</span>\n        fact.storeProduct\n    <span class=\"hljs-keyword\">where</span>\n        storeKey <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> storeKey <span class=\"hljs-keyword\">from</span> config.StoreFilter)\n        <span class=\"hljs-keyword\">and</span> newProductFlag = <span class=\"hljs-number\">1</span>\n),\n\nAnotherTable <span class=\"hljs-keyword\">as</span> (\n    ...\n)\n\n    <span class=\"hljs-keyword\">select</span>\n         trx.transactionKey\n        ,trx.<span class=\"hljs-built_in\">date</span>\n        ,trx.storeKey\n        ,trx.productKey\n        ,trx.netSales\n    <span class=\"hljs-keyword\">from</span>\n        fact.TransactionHistory trx\n            inner <span class=\"hljs-keyword\">join</span>\n        NewProducts np\n                <span class=\"hljs-keyword\">on</span> trx.productKey = np.productKey;</code></pre>\n<h3 id=\"create-table-statements\">Create table statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> base.Revenue (\n     contractKey <span class=\"hljs-built_in\">bigint</span>\n    ,dataDate <span class=\"hljs-built_in\">date</span>\n    ,<span class=\"hljs-keyword\">category</span> <span class=\"hljs-built_in\">text</span>\n    ,<span class=\"hljs-keyword\">value</span> <span class=\"hljs-built_in\">numeric</span>\n\n    <span class=\"hljs-keyword\">constraint</span> baseRevenuePrimaryKey primary <span class=\"hljs-keyword\">key</span> (dataDate, contractKey, <span class=\"hljs-keyword\">category</span>)\n);</code></pre>\n<h3 id=\"insert-statements\">Insert statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> dim.Customer (\n     contractKey\n    ,customerKey\n    ,customerType\n    ,activationDate\n    ,deactivationDate\n    ,billingLanguage\n    ,birthDate\n    ,tenure\n)\n    <span class=\"hljs-keyword\">select</span>\n         contract_Id <span class=\"hljs-keyword\">as</span> contractKey\n        ,customer_Id <span class=\"hljs-keyword\">as</span> customerKey\n        ,cust_type_id <span class=\"hljs-keyword\">as</span> customerType\n        ,<span class=\"hljs-keyword\">to_date</span>(activation_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> activationDate\n        ,<span class=\"hljs-keyword\">to_date</span>(deactivation_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> deactivationDate\n        ,bill_address <span class=\"hljs-keyword\">as</span> billingAddress\n        ,bill_language <span class=\"hljs-keyword\">as</span> billingLanguage\n        ,<span class=\"hljs-keyword\">to_date</span>(birth_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> birthDate\n        ,tenure\n    <span class=\"hljs-keyword\">from</span>\n        import.Customer;</code></pre>\n<h3 id=\"update-statements\">Update statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">update</span>\n    base.Traffic\n<span class=\"hljs-keyword\">set</span>\n     dataDate = <span class=\"hljs-keyword\">to_date</span>(<span class=\"hljs-string\">'2016/11'</span>, <span class=\"hljs-string\">'YYYY-MM'</span>)\n    ,updateDate = <span class=\"hljs-keyword\">now</span>()\n<span class=\"hljs-keyword\">where</span>\n    customerKey <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> customerKey <span class=\"hljs-keyword\">from</span> base.NewCustomer);</code></pre>\n<h3 id=\"delete-statements\">Delete statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span>\n    base.Traffic\n<span class=\"hljs-keyword\">where</span>\n    dataDate = <span class=\"hljs-keyword\">to_date</span>(<span class=\"hljs-string\">'2013/03'</span>, <span class=\"hljs-string\">'YYYY-MM'</span>);</code></pre>\n","date":"November 19, 2016"},{"id":3,"route":"predicting-churn-without-machine-learning","title":"Predicting Churn without Machine Learning","content":"<p>So, what is <a href=\"https://en.wikipedia.org/wiki/Churn_rate\">churn</a>, and why do we care?</p>\n<p>In a business context, churn or churn rate refers to the number of customers leaving your business. Typically, this measure is tracked in subscription-based business models (like telecom operators, or most SaaS online startups), since it&#39;s cheaper to retain current customers than acquire them. The aim is to predict the point at which the customer decides to leave (before the subscription runs out) so we can try to retain the customer... perhaps by offering a discount, or other goodies. This is especially important for your high-value customers!</p>\n<p>In this post I will describe a way of predicting churn based on customers&#39; inactivity profile that I&#39;ve applied in various client engagements. Without using machine learning algorithms, the model delivers an interpretable prediction of churn that gives a fairly accurate insight into the customers leaving the base. This post will not cover the implementation details - it should be straight forward to do this from the conceptual understanding taken from this post (I&#39;ve previously implemented this in SQL, Python, and SAS). Also, I won&#39;t be covering other related topics that follow from this, like calculating the value of churners to give a view of the value that is flowing out of a business (if you&#39;re interested in this or have questions, feel free to reach out!).</p>\n<p>Let&#39;s start...</p>\n<h2 id=\"customer-activity\">Customer Activity</h2>\n<p>Before we start predicting churn, we need to track our customers&#39; activity over time. The objective being to know if a customer is using the service. But what does activity mean? Activity can be defined in numerous ways (below are some examples). A customer is active:</p>\n<ul>\n<li>If a customer&#39;s subscription hasn&#39;t expired</li>\n<li>When the customer performs an outgoing event in a given month (e.g. outgoing call or message in a telecom customer)</li>\n<li>If a customer has generated some revenue in a given month (non-negative ARPU)</li>\n<li>If a customer has any outgoing or incoming</li>\n<li>A combination of these but for a period of three months</li>\n</ul>\n<p>For our purposes we will be analysing customer behaviour over months</p>\n<p>Once we decide on which definition to use, we can apply it to calculate a binary value (1 or 0) for each month: If in month x, customer is active, then set activity value to one, otherwise leave as zero.</p>\n<p>I&#39;ve typically used the total monthly ARPU as the definition for activity, but this largely depends on the context of your analysis.</p>\n<h2 id=\"-and-inactivity\">... and Inactivity</h2>\n<p>Now that we have a monthly activity flag for each customer, we need to use this to build an inactivity profile. What this means is that, for each customer, we want to count the number of consecutive months of inactivity. We can visualise this as follows, where the blue table shows the activity of each customer for each month, and the green table the inactivity profile. I have chosen a one year window of analysis in this example (the total span of time we&#39;re analyzing) - I will refer to this in my explanation below:</p>\n<ul>\n<li><strong>Customer 1</strong> - this customer enters our window of analysis as active, and then becomes inactive in May (this being the first inactive month). The customer then continues being inactive till December, which is the end of our window of analysis. The inactivity profile therefore counts the number of consecutive inactive months from May till December.</li>\n<li><strong>Customer 2</strong> - like Customer 1, this one starts-off in active state. However, this customer stops being active between March and June, has a single month of activity, after which she has a couple of months of inactivity before returning to an active state for the final three months in our window of analysis. In this case our count of consecutive inactive months resets each time the customer returns to an active state. It is typical to find this &#39;on-off&#39; behaviour.</li>\n<li><strong>Customer 3</strong> - our final example customer enters our window of analysis in inactive state. This can happen either because the customer&#39;s subscription has already expired (probably best to have excluded these before starting the analysis), or the customer is inactive. As we might not have visibility before the window of analysis, if the customer has already been inactive for a few months, we won&#39;t know. Therefore, we flag these months specifically - I use the value -1 for this purpose.</li>\n</ul>\n","date":"April 16, 2017"}];
  
  module.exports = {
      blogPosts,
  };
  