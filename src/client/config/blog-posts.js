
  const blogPosts = [{"id":1,"route":"on-transposing-data","title":"On Transposing Data","content":"<p>A transpose (or &quot;pivot&quot;) is a way of transforming data from one view to another. There are infinitely many ways of transforming data, and each attempts to get data in a form that&#39;s easier to view, analyse or process further. The definition of the verb &quot;transpose&quot; is to &quot;<em>cause (two or more things) to exchange places</em>&quot;. So, how does this apply to data, and when might such a transformation be useful? To answer this, let&#39;s go through some quick examples.</p>\n<h3 id=\"example-1---simple-row-to-column-transpose\">Example 1 - Simple row-to-column transpose</h3>\n<p>When reading about transposing data, some will (naively) think solely of exchanging rows for columns (and vice versa). This example illustrates this transformation. The data shows the sales volume per quarter for a set of regions.</p>\n<p><img src=\"/img/on-transposing-data-1.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p><img src=\"/img/on-transposing-data-2.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Visually, this transpose &quot;rotates&quot; the data over an invisible diagonal line running through the table. No information is lost through aggregation — the values simply change position, giving a different view of the data. This might be useful in making data easier to read or chart.</p>\n<h3 id=\"example-2--transposing-over-a-group-field\">Example 2 — Transposing over a &quot;group&quot; field</h3>\n<p>Now consider a billing table that captures customer transactions in a given month, as shown below (Raw table 2). Say we want to analyse the total amount for each revenue group, and that we want this visible in one row (we discuss why later on) — in other words, we want an output table with the different revenue groups as column headers, and a row of total values for each.</p>\n<p><img src=\"/img/on-transposing-data-3.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p><img src=\"/img/on-transposing-data-4.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>This can be achieved by transposing the table over a given group field (<strong>Revenue Group</strong>). The process entails aggregating a numeric field (<strong>Amount</strong>) for each distinct group. Notice that we&#39;re still performing a form of &#39;row-to-column&#39; exchange on a subset of the table (the <strong>Revenue Group</strong> field values become column headers, and the <strong>Amount</strong> field is aggregated into a single row).</p>\n<p>It isn&#39;t hard to see the value of this transpose operation — useful information can be gleaned from raw data with a single transformation. This can be used to verify totals, run integrity checks on raw data, view the evolution of variables etc.</p>\n<h3 id=\"example-3--transposing-over-a-group-field-preserving-an-id-field\">Example 3 — Transposing over a &quot;group&quot; field, preserving an &quot;id&quot; field</h3>\n<p>Taking the previous example further, let&#39;s say that we want to view each customer&#39;s total revenue breakdown for the month — in other words, we want a &#39;one-row-per-customer&#39; view broken-down into the different revenue groups. Using the same data as in <strong>Example 2</strong>, the resulting table would look like this:</p>\n<p><img src=\"/img/on-transposing-data-5.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>We arrive at this result by transposing the table over a given group field (<strong>Revenue Group</strong>), whilst preserving an id field (<strong>Customer ID</strong>). The process entails aggregating numeric field (<strong>Amount</strong>) for each distinct group and id. This transformation naturally keeps distinct values of the id field in a separate row.</p>\n<p>Apart from giving a clear view to the human eye of the value of each group for every id (everything&#39;s in one row), there is another reason why such a view is handy. Each row can be viewed as an array of values that can be iterated over and processed further. To illustrate this, imagine that instead of different revenue groups (<strong>rev_A</strong>, <strong>rev_B</strong>,…), we had transposed the monthly snapshots of a single revenue group (<strong>rev_A_month_1</strong>, <strong>rev_A_month_2</strong>,…), resulting in the following table:</p>\n<p><img src=\"/img/on-transposing-data-6.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Using this view of the data, we could iterate over all rows (i.e. all customers) — treating each as an <strong>array of values</strong> — and run our analyses on each array, in turn. For example, we could run an analysis that tries to predict customer churn based on monthly spend activity.</p>\n<hr>\n<p>We now have a bit of more clarity on how data can be transposed — but how can we perform this transformation on our own data, and what tools are available to us? If you&#39;re like me, you want to be able to do this via a shell, processing delimited text files through a carefully crafted pipe of standard UNIX programs (or even better, a single program!). But in order to appreciate the beauty of data analysis in the UNIX environment, let&#39;s examine the alternatives.</p>\n<h2 id=\"sql-postgresql-94\">SQL *PostgreSQL 9.4</h2>\n<p>SQL is the de facto language for data analysis on databases. However, carrying-out a transpose in SQL can force us to write unclean code that is hard to maintain. There is also the issue of having to import the raw data into a database before following this approach. If we wanted to transpose the table from <strong>Example 2</strong> by group and id, we could write the following code:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">select</span>\n  customer_id\n  ,<span class=\"hljs-keyword\">sum</span>(rev_A) <span class=\"hljs-keyword\">as</span> rev_A\n  ,<span class=\"hljs-keyword\">sum</span>(rev_B) <span class=\"hljs-keyword\">as</span> rev_B\n  ,<span class=\"hljs-keyword\">sum</span>(rev_C) <span class=\"hljs-keyword\">as</span> rev_C\n<span class=\"hljs-keyword\">from</span> (\n  <span class=\"hljs-keyword\">select</span>\n    customer_id\n    ,<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">when</span> revenue_group <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'rev_A'</span>) <span class=\"hljs-keyword\">then</span> amount <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">as</span> rev_A\n    ,<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">when</span> revenue_group <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'rev_B'</span>) <span class=\"hljs-keyword\">then</span> amount <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">as</span> rev_B\n    ,<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">when</span> revenue_group <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'rev_C'</span>) <span class=\"hljs-keyword\">then</span> amount <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">as</span> rev_C\n  <span class=\"hljs-keyword\">from</span>\n    <span class=\"hljs-keyword\">raw</span>\n) t1\n<span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span>\n  customer_id</code></pre>\n<p>But this code is not exactly an elegant solution to our problem. Imagine that next month the business decides to add a new revenue type <strong>rev_D</strong>. The above code would not capture this new group in the output table — in other words, changes in structure of the source data will require a modification of the code; If we were running this code as part of a monthly summary report, this solution just wouldn&#39;t do!</p>\n<p>PostgreSQL provides another means of transposing the data the way we want via the <a href=\"http://www.postgresql.org/docs/9.4/static/tablefunc.html\">CROSSTAB</a> function (other database systems like Microsoft&#39;s SQL Server, or Oracle have a <code>PIVOT</code> function that achieves the same result):</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">select</span>\n  *\n<span class=\"hljs-keyword\">from</span>\n  crosstab (\n   '<span class=\"hljs-keyword\">select</span> customer_id, revenue_group ,<span class=\"hljs-built_in\">sum</span>(amount) as amount\n    <span class=\"hljs-keyword\">from</span> raw\n    <span class=\"hljs-built_in\">group</span> <span class=\"hljs-keyword\">by</span> customer_id, revenue_group\n    order <span class=\"hljs-keyword\">by</span> customer_id'\n  ,'<span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">distinct</span> revenue_groups <span class=\"hljs-keyword\">from</span> raw'\n  )\n  as (\n     customer_id <span class=\"hljs-type\">int</span>\n    ,rev_A      real\n    ,rev_B      real\n    ,rev_C      real\n  );</code></pre>\n<p>However, this still suffers from the previous problem, as we need to modify the code in response to changes in the structure of the data; specifically, we are required to define the columns and data types for the output table (see the <code>AS</code> definition in the <code>FROM</code> clause). We could of course generate dynamic SQL to remedy this — that is, executing a code-generated SQL query that adds the distinct groups via a <strong>cursor</strong>. We would, however, have to modify the code (or write a separate query) if we wanted to transpose over the group field (without the id) instead.</p>\n<h2 id=\"sas\">SAS</h2>\n<p>SAS, with it&#39;s archaic 70&#39;s syntax, does actually have a transpose function that gets us close to an ideal solution… the drawbacks are:</p>\n<ul>\n<li>SAS does require us (like databases) to import data before we process it, which means having to define column data types and sizes. This also forces us to redefine these should our data change or exceed these limits later on;</li>\n<li>SAS&#39;s transpose function expects the data in a form that has no duplicate group values for each id; that is, the data would have to be aggregated before transposing. Taking the data from <strong>Example 2</strong>, we would have to go from this:</li>\n</ul>\n<p><img src=\"/img/on-transposing-data-7.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>to this…</p>\n<p><img src=\"/img/on-transposing-data-8.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Once the data is in a SAS-acceptable form, we can go ahead and transpose as follows:</p>\n<h3 id=\"simple-transpose-rows-to-columns\">Simple transpose (&#39;rows-to-columns&#39;)</h3>\n<pre><code class=\"hljs language-sas\">proc transpose <span class=\"hljs-attribute\">data</span>=raw <span class=\"hljs-attribute\">out</span>=output_simple;\nrun;</code></pre>\n<h3 id=\"transpose-over-group-requires-prior-aggregation\">Transpose over group (requires prior aggregation)</h3>\n<pre><code class=\"hljs language-sas\"><span class=\"hljs-keyword\">proc</span><span class=\"hljs-title\"> transpose</span> data=raw<span class=\"hljs-title\"> out=output_group;</span>\n<span class=\"hljs-title\">  id</span> revenue_group;<span class=\"hljs-title\">\n  var</span> amount;<span class=\"hljs-title\">\nrun;</span></code></pre>\n<h3 id=\"transpose-over-group-preserving-id-requires-prior-aggregation\">Transpose over group, preserving id (requires prior aggregation)</h3>\n<pre><code class=\"hljs language-sas\">proc transpose data=raw out=output_group_id<span class=\"hljs-comment\">;</span>\n  <span class=\"hljs-keyword\">by </span>customer_id<span class=\"hljs-comment\">;</span>\n  id revenue_group<span class=\"hljs-comment\">;</span>\n  var amount<span class=\"hljs-comment\">;</span>\nrun<span class=\"hljs-comment\">;</span></code></pre>\n<p>Alas, SAS is proprietary software (with extremely prohibitive license costs) that ultimately restricts our freedom as users. Moreover, there are many technically excellent, free and open source tools available that allow you do everything you do currently in SAS (and more).</p>\n<h2 id=\"awk\">AWK</h2>\n<p>AWK is a natural choice for this type of problem as it provides a simple processing model and language that enables a fast <strong>write-exectute-test</strong> feedback-loop. For instance, the code for transposing over the group field (as in <strong>Example 2</strong>) can be written in 19 lines:</p>\n<pre><code class=\"hljs language-awk\">BEGIN {\n  FS=<span class=\"hljs-string\">\"\\t\"</span>; OFS=<span class=\"hljs-string\">\"\\t\"</span>\n}\nNR &gt; <span class=\"hljs-number\">1</span> {\n  <span class=\"hljs-keyword\">if</span>($(grp) != <span class=\"hljs-string\">\"\"</span>)\n    <span class=\"hljs-built_in\">unique</span>[$(grp)] += $(<span class=\"hljs-built_in\">num</span>)\n}\nEND {\n  <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%s\\t\"</span>, group)\n  <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">\"\"</span>\n  <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\\t\"</span>, <span class=\"hljs-built_in\">unique</span>[group])\n  <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">\"\"</span>\n}</code></pre>\n<p>If we saved this to a file called <code>transposeGroup.awk</code>, we could run it to transpose a text file holding our data (<code>data.txt</code>) like this:</p>\n<pre><code class=\"hljs language-bash\">$ gawk -f transposeGroup.awk <span class=\"hljs-attribute\">grp</span>=4 <span class=\"hljs-attribute\">num</span>=5 data.txt</code></pre>\n<p>AWK doesn&#39;t recognise field names, so you better know the column index of the fields you want to use (notice that we pass the column indexes for both the field containing the group values, and the numeric values to be aggregated, respectively). Although column indexes can be extracted easily (<code>head -n1 data.txt | tr $&#39;\\t&#39; $&#39;\\n&#39; | cat -n</code>), these indexes would change if the structure of our data changes, e.g. if new fields where added to <code>data.txt</code>. A rule of thumb is to never rely on &#39;magic numbers&#39; — in this case, the ability to refer to our fields by name would provide a more future-proof solution (typically, field names should change little over time, if at all).</p>\n<p>Similarly, the code to transpose over the <code>group</code> and <code>id</code> fields can composed as follows:</p>\n<pre><code class=\"hljs language-awk\">#!/bin/bash\ndataFile=$<span class=\"hljs-number\">1</span>\nidField=$<span class=\"hljs-number\">2</span>\ngroupField=$<span class=\"hljs-number\">3</span>\nnumField=$<span class=\"hljs-number\">4</span>\ngawk '\nBEGIN {\n  FS=<span class=\"hljs-string\">\"\\t\"</span>; OFS=<span class=\"hljs-string\">\"\\t\"</span>\n}\n# Get id column name (to <span class=\"hljs-built_in\">print</span> later)\nNR == <span class=\"hljs-number\">1</span> &amp;&amp; pass == <span class=\"hljs-number\">1</span> {\n  idHeader = $(id)\n}\n# Get <span class=\"hljs-built_in\">unique</span> groups\nFNR &gt; <span class=\"hljs-number\">1</span> &amp;&amp; pass == <span class=\"hljs-number\">1</span> {\n  <span class=\"hljs-keyword\">if</span>($(grp) != <span class=\"hljs-string\">\"\"</span>)\n    <span class=\"hljs-built_in\">unique</span>[$(grp)] = <span class=\"hljs-number\">0</span>\n}\n# <span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">unique</span> groups as headers\npass == <span class=\"hljs-number\">2</span> &amp;&amp; FNR == <span class=\"hljs-number\">1</span> {\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%s\\t\"</span>, idHeader)\n  <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%s\\t\"</span>, group)\n  <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">\"\"</span>\n}\n# aggregate group <span class=\"hljs-built_in\">values</span> <span class=\"hljs-keyword\">for</span> each id\nFNR &gt; <span class=\"hljs-number\">1</span> &amp;&amp; pass == <span class=\"hljs-number\">2</span> {\n\n  rowId = $(id)\n  <span class=\"hljs-keyword\">if</span>(currentId == <span class=\"hljs-string\">\"\"</span>)\n    currentId = rowId\n  <span class=\"hljs-keyword\">if</span>(rowId != <span class=\"hljs-string\">\"\"</span> &amp;&amp; $(grp) != <span class=\"hljs-string\">\"\"</span>) {\n    <span class=\"hljs-keyword\">if</span>(rowId == currentId)\n      <span class=\"hljs-built_in\">unique</span>[$(grp)] += $(<span class=\"hljs-built_in\">num</span>)\n    <span class=\"hljs-keyword\">else</span> {\n      # <span class=\"hljs-built_in\">print</span> output line\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%s\\t\"</span>, currentId)\n      <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\\t\"</span>, <span class=\"hljs-built_in\">unique</span>[group])\n      <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">\"\"</span>\n\n      # clear <span class=\"hljs-built_in\">array</span> <span class=\"hljs-built_in\">values</span>\n      <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n        <span class=\"hljs-built_in\">unique</span>[group] = <span class=\"hljs-string\">\"\"</span>\n\n      # aggregate current <span class=\"hljs-built_in\">row</span>\n      currentId = rowId\n      <span class=\"hljs-built_in\">unique</span>[$(grp)] += $(<span class=\"hljs-built_in\">num</span>)\n    }\n  }\n}\n#<span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">last</span> <span class=\"hljs-built_in\">row</span>\nEND {\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%s\\t\"</span>, currentId)\n  <span class=\"hljs-keyword\">for</span>(group <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">unique</span>)\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\\t\"</span>, <span class=\"hljs-built_in\">unique</span>[group])\n  <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">\"\"</span>\n}' id=$idField grp=$groupField <span class=\"hljs-built_in\">num</span>=$numField pass=<span class=\"hljs-number\">1</span> $dataFile pass=<span class=\"hljs-number\">2</span> $dataFile</code></pre>\n<p>The fact that the code scans twice over the data file forces us to encapsulate the code in a shell script. To run this on our data, we would save the code in a file <code>transposeIdGroup.awk</code>, and execute the following:</p>\n<pre><code class=\"hljs language-bash\">$ ./transposeIdGroup<span class=\"hljs-selector-class\">.awk</span> data<span class=\"hljs-selector-class\">.txt</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span></code></pre>\n<p>AWK allows us to script the transpose functionality we want in few lines (I&#39;ve left the &#39;row-to-column&#39; transpose for the reader to figure out). However, these scripts are more suited to be executed in an ad-hoc fashion, than in a repeatable process (such as cron job) as it cannot handle the data changing structure.</p>\n<h2 id=\"rs\">rs</h2>\n<p>This UNIX tool only handles simple transposes (&#39;row-to-column&#39;), but deserves a quick mention for the sake of completeness. If we have the following data in <code>data_simple.txt</code>:</p>\n<pre><code class=\"hljs language-bash\">$ cat data_simple.txt\nA B C\n<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span> y<span class=\"hljs-number\">1</span> z<span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span> y<span class=\"hljs-number\">2</span> z<span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span> y<span class=\"hljs-number\">3</span> z<span class=\"hljs-number\">3</span></code></pre>\n<p>We can transpose this by running:</p>\n<pre><code class=\"hljs language-bash\">$ cat data_simple.txt | rs -<span class=\"hljs-keyword\">c</span>$'\\t' -T\nA <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span>\nB y<span class=\"hljs-number\">1</span> y<span class=\"hljs-number\">2</span> y<span class=\"hljs-number\">3</span>\nC z<span class=\"hljs-number\">1</span> z<span class=\"hljs-number\">2</span> z<span class=\"hljs-number\">3</span></code></pre>\n<p>Now that we have a better idea of the methods available, we are better placed to decide which best fits our needs. You might have noticed, however, that there isn&#39;t a method that simultaneously matches all of the following requirements:</p>\n<ol>\n<li>Doesn&#39;t need importing</li>\n<li>Doesn&#39;t involve writing a script</li>\n<li>Allows field-name matching (not only column indexes)</li>\n<li>Accepts delimited text files</li>\n<li>Can be run from the terminal</li>\n<li>Provides different aggregation types (sum, count, average)</li>\n<li>Executes in parallel</li>\n</ol>\n<p>Enter <strong>tpose</strong>... a UNIX-based terminal program for transposing delimited text-files.</p>\n<h3 id=\"simple-transpose\">Simple transpose</h3>\n<p>A simple transpose (&#39;row-to-column&#39;) needs no options. The data from <strong>Example 1</strong> can be processed by:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex1_simple.txt\nQuarter Q1 Q2 Q3 Q4\nEurope  <span class=\"hljs-number\">2</span>  <span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">4</span>\nAsia    <span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">6</span>\nUS      <span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">1</span>  <span class=\"hljs-number\">2</span>  <span class=\"hljs-number\">3</span></code></pre>\n<h3 id=\"group-transpose\">Group transpose</h3>\n<p>To transpose a numerical variable over a a set of groups, we need to provide the -G (or — group) and -N (or — numeric) options, to specify the group, and numeric fields. The data from Example 2 (&quot;Raw table 2 — Billing data for a given month&quot;) is transposed as follows:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex2_group.txt -Grevenue_group -Namount\n<span class=\"hljs-keyword\">rev_A </span><span class=\"hljs-keyword\">rev_B </span><span class=\"hljs-keyword\">rev_C\n</span><span class=\"hljs-number\">13</span>.<span class=\"hljs-number\">00</span> <span class=\"hljs-number\">12</span>.<span class=\"hljs-number\">00</span> <span class=\"hljs-number\">15</span>.<span class=\"hljs-number\">00</span></code></pre>\n<h3 id=\"group-and-id-transpose\">Group and ID transpose</h3>\n<p>Using the same data from <strong>Example 2</strong>, we can transpose over groups and id&#39;s via the -I (or — id), -G (or — group), and -N (or — numeric) options:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex2_group.txt -Icustomer_id — Grevenue_group -Namount\nCustomer_id rev_A rev_B rev_C\n <span class=\"hljs-number\">1</span>          <span class=\"hljs-number\">2.00</span>  <span class=\"hljs-number\">3.00</span>  <span class=\"hljs-number\">0.00</span>\n <span class=\"hljs-number\">2</span>          <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">6.00</span>\n <span class=\"hljs-number\">3</span>          <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">9.00</span>  <span class=\"hljs-number\">9.00</span>\n <span class=\"hljs-number\">4</span>          <span class=\"hljs-number\">11.00</span> <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">0.00</span></code></pre>\n<p>There are a few points to note:</p>\n<ul>\n<li>Transposing over group, and ID fields requires the first line of the data file to be a header row with field names</li>\n<li>All operations are performed using floating-point values — values are output as such</li>\n<li>-I, -G, and -N options are case-insensitive (revenue_group = rEvEnUe_GrOuP)</li>\n</ul>\n<h3 id=\"field-indexes-instead-of-names\">Field indexes instead of names</h3>\n<p>It&#39;s sometimes easier to refer to fields by number — that is, the position relative to other fields. This is supported in tpose via the -i (or — indexed) option. If this option is used, tpose will expect a number instead of a name. If we take the same data from <strong>Example 2</strong>, we would perform the previous transpose operation by:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex2_group.txt -i — I1 — G2 -N3\nCustomer_id rev_A rev_B rev_C\n<span class=\"hljs-number\">1</span>           <span class=\"hljs-number\">2.00</span>  <span class=\"hljs-number\">3.00</span>  <span class=\"hljs-number\">0.00</span>\n<span class=\"hljs-number\">2</span>           <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">6.00</span>\n<span class=\"hljs-number\">3</span>           <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">9.00</span>  <span class=\"hljs-number\">9.00</span>\n<span class=\"hljs-number\">4</span>           <span class=\"hljs-number\">11.00</span> <span class=\"hljs-number\">0.00</span>  <span class=\"hljs-number\">0.00</span></code></pre>\n<p>An easy way of getting the field indexes is via the following pipe (assuming tab delimiter):</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-symbol\">$</span> head -n1 data_ex2_group.txt | tr <span class=\"hljs-symbol\">$</span><span class=\"hljs-string\">'\\t'</span> <span class=\"hljs-symbol\">$</span><span class=\"hljs-string\">'\\n'</span> | cat -n\n<span class=\"hljs-number\">1</span> Customer_id\n<span class=\"hljs-number\">2</span> Revenue_group\n<span class=\"hljs-number\">3</span> Amount</code></pre>\n<h3 id=\"types-of-aggregation\">Types of aggregation</h3>\n<p>Imagine that instead of transposing over groups (or groups and IDs) and summing the numerical field, we want to count each instance instead, or calculate an average using the sum of the numerical field and the count of each instance. We can do this with tpose by passing the type of aggregation via the -a (or — aggregate) option:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex2_group.txt -i — I1 — G2 -N3 -acount\ncustomer_id rev_A rev_B rev_C\n<span class=\"hljs-number\">1</span>           <span class=\"hljs-number\">1</span>     <span class=\"hljs-number\">1</span>     <span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">2</span>           <span class=\"hljs-number\">0</span>     <span class=\"hljs-number\">0</span>     <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">3</span>           <span class=\"hljs-number\">0</span>     <span class=\"hljs-number\">2</span>     <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">4</span>           <span class=\"hljs-number\">2</span>     <span class=\"hljs-number\">0</span>     <span class=\"hljs-number\">0</span>\n\n$ tpose data_ex2_group.txt -i — I1 — G2 -N3 -aavg\ncustomer_id rev_A rev_B rev_C\n<span class=\"hljs-number\">1</span>           <span class=\"hljs-number\">2.00</span>  <span class=\"hljs-number\">3.00</span>  nan\n<span class=\"hljs-number\">2</span>           nan   nan   <span class=\"hljs-number\">6.00</span>\n<span class=\"hljs-number\">3</span>           nan   <span class=\"hljs-number\">4.50</span>  <span class=\"hljs-number\">9.00</span>\n<span class=\"hljs-number\">4</span>           <span class=\"hljs-number\">5.50</span>  nan   nan</code></pre>\n<h3 id=\"executing-in-parallel\">Executing in parallel</h3>\n<p>Processing large files sequentially might take some time, so why not leverage the multiple cores in our machines? Files larger than one gigabyte, can be transposed in parallel via the -P (or — parallel) option:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_large<span class=\"hljs-selector-class\">.txt</span> output<span class=\"hljs-selector-class\">.txt</span> -P -Icustomer_id -Grevenue_group -Namount</code></pre>\n<p>Notice that in this case we specify an output file (output.txt) instead of letting tpose print everything to the screen.</p>\n<h3 id=\"changing-delimiter\">Changing delimiter</h3>\n<p>If the data is not tab-delimited, we can specify a different delimiter via the -d (or — delimiter) option. Here we specify a comma for CSV files:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data<span class=\"hljs-selector-class\">.csv</span> output<span class=\"hljs-selector-class\">.txt</span> -d, -P -Icustomer_id -Grevenue_group   -Namount</code></pre>\n<h3 id=\"add-a-prefixsuffix-to-output-fields\">Add a prefix/suffix to output fields</h3>\n<p>Suppose we wanted to add a prefix or suffix to the transposed group names (say, so that they follow a pattern and are easy to group with a wildcard later on). This can be achieved with the -p ( — prefix) and/or -s ( — suffix) options:</p>\n<pre><code class=\"hljs language-bash\">$ tpose data_ex2_group.txt -i — I1 — G2 -N3 -pxxx_ -s_yyy\ncustomer_id xxx_rev_A_yyy xxx_rev_B_yyy xxx_rev_C_yyy\n<span class=\"hljs-number\">1</span>           <span class=\"hljs-number\">2.00</span>          <span class=\"hljs-number\">3.00</span>          <span class=\"hljs-number\">0.00</span>\n<span class=\"hljs-number\">2</span>           <span class=\"hljs-number\">0.00</span>          <span class=\"hljs-number\">0.00</span>          <span class=\"hljs-number\">6.00</span>\n<span class=\"hljs-number\">3</span>           <span class=\"hljs-number\">0.00</span>          <span class=\"hljs-number\">9.00</span>          <span class=\"hljs-number\">9.00</span>\n<span class=\"hljs-number\">4</span>           <span class=\"hljs-number\">11.00</span>         <span class=\"hljs-number\">0.00</span>          <span class=\"hljs-number\">0.00</span></code></pre>\n<p>Grab tpose <a href=\"https://github.com/jmsmistral/tpose\">here</a></p>\n","date":"September 26, 2015"},{"id":2,"route":"improve-your-postgresql-workflow-with-vim-and-dbext","title":"Improve your PostgreSQL workflow with vim and dbext","content":"<p>If you&#39;ve worked with PostgreSQL in the past using the <a href=\"http://www.postgresql.org/docs/current/static/app-psql.html\">psql</a> client you might have noticed that, although powerful, it&#39;s not a tool geared for writing (or reading) complex multi-line queries, or following a <strong>&#39;write-execute-refine&#39; workflow</strong>; that is, where you write some code, execute it, refine the code based on results... So, let&#39;s say I write some SQL code in vim, and I want to run it to see if it works. I would have to copy the block of code to a new buffer, save as it as a file, switch to psql, type <code>\\i &lt;path-to-file&gt;</code>, hit Enter and wait for the results (... oh, and now you have a new file to maintain temporarily).</p>\n<blockquote>\n<h2 id=\"wouldnt-it-be-nice-to-be-able-to-write-execute-and-view-the-results-from-within-vim\">Wouldn&#39;t it be nice to be able to write, execute, and view the results from within vim?</h2>\n</blockquote>\n<p>We can definitely streamline this workflow, and reduce it to one or two keystrokes from within vim (because god forbid we move our fingers away from the &#39;hjkl&#39; position!).</p>\n<p><a href=\"https://github.com/vim-scripts/dbext.vim\">dbext</a> is a vim plugin that aims to do exactly that (credit to the author Peter Bagyinszki)! Don&#39;t be put-off by the poorly presented <a href=\"https://github.com/vim-scripts/dbext.vim\">Github</a> or <a href=\"http://www.vim.org/scripts/script.php?script_id=356\">Vim scripts</a> page - the plugin comes with a helpful tutorial (described below) that covers what you need to know. Here, I will show you what I had to do to get started using dbext.</p>\n<h2 id=\"what-you-need\">What you need</h2>\n<p>You need to have <strong>vim 7+</strong>, and the <strong>psql</strong> client installed locally. You&#39;ll also need access to a <strong>PostgreSQL</strong> server.</p>\n<h2 id=\"download-and-configure-dbext\">Download and configure dbext</h2>\n<p>I use the <a href=\"https://github.com/tpope/vim-pathogen\">Pathogen</a> vim plugin to easily install other plugins and run-time files. If you do too, then just navigate to the <code>~/.vim/bundle/</code> folder in your home directory and clone the dbext Github repository.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> <span class=\"hljs-built_in\">cd</span> ~/.vim/bundle/</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> git <span class=\"hljs-built_in\">clone</span> https://github.com/vim-scripts/dbext.vim</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> ls</span>\ndbext.vim/</code></pre>\n<p><strong>That&#39;s it - installed!</strong>&nbsp;&nbsp;&nbsp;🎉</p>\n<p>dbext works by relating every vim buffer to a database connection profile that we define in our <code>.vimrc</code>. A connection profile describes a set of parameters needed to connect to a database, such as username, host, port, database name etc. We can define various profiles, and also define a default profile to use whenever a new buffer is opened in vim. Open your <code>.vimrc</code> file and enter the following two lines, making sure you substitute your values for host, port, dbname, and user (for PostgreSQL, leave the type as &#39;PGSQL&#39;). In the example below, we are connecting to a database called <strong>&#39;jms&#39;</strong>, as user <strong>&#39;jms&#39;</strong>, on a server running on the same machine <strong>&#39;localhost&#39;</strong> via port <strong>5433</strong>.</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" Each profile has the form:\n\"</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile<span class=\"hljs-number\">_</span><span class=\"hljs-string\">'profilename'</span> = <span class=\"hljs-string\">'var=value:var=value:...'</span>\n<span class=\"hljs-keyword\">let</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile<span class=\"hljs-number\">_p</span>sql = <span class=\"hljs-string\">'type=PGSQL:host=localhost:port=5433:dbname=jms:user=jms'</span>\n<span class=\"hljs-keyword\">let</span> g:dbext<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">default</span><span class=\"hljs-number\">_p</span>rofile = <span class=\"hljs-string\">'psql'</span></code></pre>\n<p><strong>Notice that we&#39;re not entering our password</strong> - this is because the psql client will either ask us for a password when we connect, or looks for a <code>.pgpass</code> file in our home directory. I recommend having a <code>.pgpass</code> file. This file typically has a single line of the form: <code>hostname:port:database:username:password</code></p>\n<h2 id=\"running-queries\">Running queries</h2>\n<p>Now that we have dbext installed, let&#39;s see what we can do with it! I do recommend taking some time to read over the tutorial that comes with dbext by typing the following in vim:</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-selector-pseudo\">:h</span> <span class=\"hljs-selector-tag\">dbext-tutorial</span></code></pre>\n<p>Now let&#39;s start running some code! Let&#39;s get some data from a table in our database.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> staging.customer;</code></pre>\n<p><strong>We can run this either in normal mode or visual mode</strong>. In normal mode, simply move the cursor somewhere within the query (in the example above this would be between the <strong>&#39;s&#39;</strong> or <strong>&#39;;&#39;</strong>, inclusive) and type the following, replacing <code>\\</code> with your leader character.</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\\se</span></code></pre>\n<p><strong>This will bring up the results buffer</strong> - a read-only split window displaying the results for the executed statement(s); To focus on this press <code>Ctrl + w</code> twice in quick succession. You can navigate the results buffer as you would any other vim buffer. To close the results, first switch to it, and then press <code>q</code>. Additionally, if the results split is too small, you can even it out by pressing <code>Ctrl + w</code> once, followed by <code>=</code>. Alternatively, you can type <code>:res +5</code> or <code>:res -5</code> to make the split window bigger or smaller by 5 rows.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-1.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>If we had multiple queries and only wanted to run one, or a couple of them, we could enter <strong>visual mode</strong> to select them (<code>Shift + v</code> followed by <code>j</code> or <code>k</code> to select rows down or up) and again type <code>\\se</code>, as before.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-2.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p><strong>Isn&#39;t that exciting?!!</strong>&nbsp;&nbsp;🤓 That&#39;s just a taster - I&#39;ve added a small reference of dbext commands at the end of this post. Before that, there&#39;s a cool feature you&#39;ll love... <strong><em>auto-completion</em></strong>.</p>\n<h2 id=\"auto-completion\">Auto-completion</h2>\n<p>When working with a large number of tables/views, it can be hard to remember all their names. dbext can help-out with a pop-up menu of potential matches. This functionality does require the following to be done:</p>\n<ul>\n<li>You must be working from a saved file ending in .sql</li>\n<li>Populate the vim dictionary using either of the following commands <code>DBCompleteTables</code>, <code>DBCompleteViews</code>, or <code>DBCompleteProcedures</code></li>\n</ul>\n<p>To avoid having to type a <code>DBComplete*</code> command whenever I start a new buffer, I added this to my <code>.vimrc</code> (this runs the given command once all plugins have been loaded):</p>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-attribute\">autocmd</span> VimEnter * DBCompleteTables</code></pre>\n<p>Once that&#39;s done and dusted, start typing a <code>SELECT</code> statement. After the <code>FROM</code> keyword, press <code>Ctrl + x</code> and <code>Ctrl + o</code> in quick succession, this will bring up a menu showing all matching tables. So, if we had started typing the name of the table, and then brought-up the menu, it would filter only tables matching what we&#39;ve typed so far. Scroll up and down the menu with <code>Ctrl + n</code> and <code>Ctrl + p</code>.</p>\n<p><img src=\"/img/improve-postgresql-workflow-vim-dbext-3.png\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<h2 id=\"quick-reference\">Quick Reference</h2>\n<h3 id=\"code-execution\">Code Execution</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-comment\">\" Execute code in normal or visual mode. (s)ql (e)xecute</span>\n\\<span class=\"hljs-keyword\">se</span>\n\n<span class=\"hljs-comment\">\" Execute just the current line. (s)ql (e)xecute (l)ine</span>\n\\sel</code></pre>\n<h3 id=\"select-from-tables\">Select from Tables</h3>\n<pre><code class=\"hljs language-vim\">\" <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span> (s)ql (t)able\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\st\n\n\"</span> <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span>, <span class=\"hljs-keyword\">prompt</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">rows</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">return</span>  (s)ql (T)able\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\sT\n\n\"</span> <span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">table</span>, <span class=\"hljs-keyword\">prompt</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">WHERE</span> clause  (s)ql (t)able (w)here\n<span class=\"hljs-string\">\" Place cursor over table name, or visual mode select schema &amp; table name\n\\stw</span></code></pre>\n<h3 id=\"describe-objects\">Describe Objects</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" Describe table (s)ql (d)escribe (t)able\n\"</span> Place cursor over table name, <span class=\"hljs-keyword\">or</span> visual mode select schema &amp; table name\n\\sdt\n\n<span class=\"hljs-string\">\" Describe procedure (s)ql (d)escribe (p)rocedure\n\"</span> Place cursor over <span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">name</span>, <span class=\"hljs-title\">or</span> <span class=\"hljs-title\">visual</span> <span class=\"hljs-title\">mode</span> <span class=\"hljs-title\">select</span> <span class=\"hljs-title\">schema</span> &amp; <span class=\"hljs-title\">procedure</span> <span class=\"hljs-title\">name</span>\n\\<span class=\"hljs-title\">sdp</span>\n\n\" <span class=\"hljs-title\">Describe</span> <span class=\"hljs-title\">procedure</span> <span class=\"hljs-params\">(s)</span><span class=\"hljs-title\">ql</span> <span class=\"hljs-params\">(d)</span><span class=\"hljs-title\">escribe</span> <span class=\"hljs-params\">(v)</span><span class=\"hljs-title\">iew</span>\n\" <span class=\"hljs-title\">Place</span> <span class=\"hljs-title\">cursor</span> <span class=\"hljs-title\">over</span> <span class=\"hljs-title\">view</span> <span class=\"hljs-title\">name</span>, <span class=\"hljs-title\">or</span> <span class=\"hljs-title\">visual</span> <span class=\"hljs-title\">mode</span> <span class=\"hljs-title\">select</span> <span class=\"hljs-title\">schema</span> &amp; <span class=\"hljs-title\">view</span> <span class=\"hljs-title\">name</span>\n\\<span class=\"hljs-title\">sdv</span></span></code></pre>\n<h3 id=\"listing-objects\">Listing Objects</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" List tables in database (s)ql (l)ist (t)able\n\"</span> Prompts <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">to</span> match tables <span class=\"hljs-keyword\">by</span> <span class=\"hljs-built_in\">name</span>\n\\slt\n\n<span class=\"hljs-string\">\" Same but for procedures\n\\slp\n\n\"</span> Same <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">for</span> views\n\\slv\n\n<span class=\"hljs-string\">\" Get list of table columns in paste buffer (s)ql (l)ist (c)olumns\n\"</span> Place cursor <span class=\"hljs-keyword\">over</span> table <span class=\"hljs-built_in\">name</span>. Recognises schemas <span class=\"hljs-keyword\">without</span> visual mode selection\n<span class=\"hljs-string\">\" Prompts for alias prefix to be added\n\\slc</span></code></pre>\n<h3 id=\"results-buffer-run-inside-results-buffer\">Results Buffer (run inside results buffer)</h3>\n<pre><code class=\"hljs language-vim\">\" Re-<span class=\"hljs-keyword\">run</span> <span class=\"hljs-keyword\">query</span> that generated current results buffer\n<span class=\"hljs-built_in\">R</span>\n\n\" <span class=\"hljs-keyword\">Close</span> results buffer\n<span class=\"hljs-built_in\">q</span></code></pre>\n<h3 id=\"command-history\">Command History</h3>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\" List recently executed statements \n\"</span> Press RETURN key <span class=\"hljs-keyword\">on</span> selected statement <span class=\"hljs-keyword\">to</span> re-execute\n\\sh</code></pre>\n","date":"January 22, 2016"},{"id":3,"route":"clean-sql","title":"Clean SQL","content":"<p>I analyse a lot of data daily, much of the time using SQL. As a language, SQL is relatively simple and self-contained, and newcomers usually don&#39;t take long to start writing code that works (after learning to think declaratively!). Like other languages, <strong>SQL can be written in a way that reads like poetry</strong>, where the logic of the query is clear to anyone who reads it. <strong>Often, however, reading someone else&#39;s SQL code is a very <a href=\"http://www.urbandictionary.com/define.php?term=clusterfuck\">unpleasant experience</a></strong>... and although it&#39;s usually code written by rookies, &#39;pro&#39; code can be just as painful at times.</p>\n<p>It seems that newcomers to SQL don&#39;t think it&#39;s important to write code that is easy to read and understand by others. Instead they focus solely on getting the data output needed. On the other hand, I feel <strong>experienced coders tend to over-engineer the formatting of the code</strong> (think <em>over alignment</em>).</p>\n<p>This has prompted me to write this post, which will serve as a living document of what I feel is the best way to write SQL code...</p>\n<h2 id=\"why-clean-code\">Why clean code?</h2>\n<p>In any project where code is written, whether for data analysis or a complex app, <strong>the compounding effects of messy code affects productivity and costs</strong>. Bad code slows down the pace of the team, making any change less and less trivial as time progresses. Unfortunately, the pace of projects, and the pressure to produce results urges the team to add more bad code. Eventually, you end-up with a colossal pile of 💩 that shatters when touched.</p>\n<blockquote>\n<h2 id=\"code-is-written-once-and-read-many-times-so-consistently-write-clear-human-readable-code\">Code is written once, and read many times. So consistently write clear, human-readable code.</h2>\n</blockquote>\n<h2 id=\"example-of-bad-code\">Example of bad code</h2>\n<p>Before I start looking at how to write clean SQL, let&#39;s explore the motivation behind this... What do you think is wrong in this first example below (sanitzed real-world example written in TSQL)?</p>\n<pre><code class=\"hljs language-sql\">SELECT\n    c<span class=\"hljs-selector-class\">.Date</span>\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span>,\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.description</span>,\n    e0<span class=\"hljs-selector-class\">.Classification</span>,\n    ExampleFlag = <span class=\"hljs-number\">1</span>,\n    FutureFcstMethod = CASE WHEN c<span class=\"hljs-selector-class\">.Discount</span> NOT NULL THEN <span class=\"hljs-string\">'Mthd1'</span>\n        WHEN (<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Uplift</span> IS NOT NULL AND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Forecast</span> IS NOT NULL) THEN <span class=\"hljs-string\">'Mthd2'</span> END,\n    SUM(IIF(e0.Flag=<span class=\"hljs-number\">0</span>, cost, NULL))/NULLIF(SUM(IIF(e0.Flag=<span class=\"hljs-number\">0</span>, sales, NULL)),<span class=\"hljs-number\">0</span>) as Rate\nFROM Dim<span class=\"hljs-selector-class\">.Product</span> <span class=\"hljs-selector-tag\">a</span>\nLEFT JOIN fst<span class=\"hljs-selector-class\">.ProductClass</span> e0 ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = e0<span class=\"hljs-selector-class\">.ProductKey</span>\nLEFT JOIN fact<span class=\"hljs-selector-class\">.Discounts</span> c ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = c<span class=\"hljs-selector-class\">.ProductKey</span>\nINNER JOIN fst<span class=\"hljs-selector-class\">.A_Final_Product_Analysis</span> <span class=\"hljs-selector-tag\">b</span> ON <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.ProductKey</span> = <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.ProductKey</span>\nAND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.TransDate</span> &lt; c<span class=\"hljs-selector-class\">.Date</span>\nWHERE <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.productKey</span> NOT IN (<span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">5678</span>, <span class=\"hljs-number\">90123</span>)\nAND e0<span class=\"hljs-selector-class\">.Classification</span> IN (<span class=\"hljs-string\">'A'</span>, <span class=\"hljs-string\">'BC'</span>, <span class=\"hljs-string\">'A21'</span>)\nAND c<span class=\"hljs-selector-class\">.Discount</span> &gt; <span class=\"hljs-number\">0</span>\nGROUP BY\n    c<span class=\"hljs-selector-class\">.Date</span>\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.Product</span>,\n    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.description</span>,\n    e0<span class=\"hljs-selector-class\">.Classification</span>,\n    CASE WHEN c<span class=\"hljs-selector-class\">.Discount</span> NOT NULL THEN <span class=\"hljs-string\">'Mthd1'</span>\n        WHEN (<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Uplift</span> IS NOT NULL AND <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.Forecast</span> IS NOT NULL) THEN <span class=\"hljs-string\">'Mthd2'</span> END</code></pre>\n<p>That&#39;s right... <strong><em>everything</em></strong>.</p>\n<p>The code is <strong>densely packed</strong>, <strong>mis-aligned</strong>, and uses <strong>obscure naming</strong>... it&#39;s hard to glean any information from it.</p>\n<h2 id=\"clean-code-rules\">Clean code rules</h2>\n<p>Most experienced programmers agree with a version of these rules. For an in-depth analysis of how to write clean code, I really recommend reading Robert Martin&#39;s <a href=\"https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882\">Clean Code</a>.</p>\n<h3 id=\"naming\">Naming</h3>\n<ul>\n<li>Name objects in a way that tells the purpose of the object - calling a field <code>acc_111</code> doesn&#39;t tell us anything. A rule of thumb is the ability to easily pronounce the name.</li>\n<li>Use <strong>camelCase</strong> for fields and <strong>TitleCase</strong> for tables - call a table <code>SalesTransactionHistory</code> instead of <code>sales_transaction_history</code>, and a field <code>totalRevenue</code> instead of <code>total_revenue</code>.</li>\n<li>Functions or stored procedures should start with a verb that tells what it does - <code>getSalesForecast</code> instead of <code>forecast</code>. Do not add any prefix like <code>sp_</code> or <code>fn_</code> or any other Hungarian Notation.</li>\n<li>Give consistent, meaningful aliases to joined tables in a query - <code>a</code>, <code>b</code>, <code>c</code> is just confusing. Instead, use <code>prd</code> for a product dimension table, or <code>sales</code> for a sales fact table.</li>\n</ul>\n<h3 id=\"formatting\">Formatting</h3>\n<ul>\n<li><strong>Don&#39;t capitalise SQL clauses</strong> like select, from, ... capital letters are hard on the eyes, and make the code look more dense.</li>\n<li>In general, <strong>structure your code vertically</strong> rather than horizontally. For example, list fields vertically in a select. If you want to be strict about it, any line should not exceed more than 80 characters in length.</li>\n<li><strong>Do not horizontally-align code</strong>. Code that has been overly aligned in this way creates too much separation between parts of the code that correspond to each other, drawing attention away from that relevant correspondence. For example, separating fields and data types in a create table statement draws you to look at the list of field names and not their data types.</li>\n<li>Lists of fields, where conditions, and tables after a from statement, must:<ul>\n<li>start on a new line</li>\n<li>have one level of indentation</li>\n<li>be left-aligned</li>\n</ul>\n</li>\n<li>Joins are clear when formatted as below, with the join clause double indented, and the joined fields triple indented.</li>\n</ul>\n<pre><code class=\"hljs language-sql\">select\n     tbl1<span class=\"hljs-selector-class\">.field1</span>\n    ,tbl1<span class=\"hljs-selector-class\">.field2</span>\nfrom\n    table1 tb1\n        inner join\n    table2 tb2\n            on  tb1<span class=\"hljs-selector-class\">.field1</span> = tb2<span class=\"hljs-selector-class\">.field1</span>\n            and tb1<span class=\"hljs-selector-class\">.field2</span> = tb2<span class=\"hljs-selector-class\">.field2</span>\n        <span class=\"hljs-attribute\">left</span> join\n    table3 tb3\n            on ...</code></pre>\n<h3 id=\"comments\">Comments</h3>\n<ul>\n<li><strong>Use comments sparingly</strong> - a comment is only needed when the code is unclear enough that it needs to be explained. Messy code won&#39;t be made better with the addition of comments.</li>\n<li>In writing a comment, restrict it to stating the general purpose of a block of code in the most concise manner possible.</li>\n<li>Never leave commented code co-existing with live code.</li>\n</ul>\n<h3 id=\"queries-functions--procedures\">Queries, Functions &amp; Procedures</h3>\n<ul>\n<li>If the logic in a single query is hard to understand, then it is probably doing too much at once. Separate the logic into multiple steps using either CTEs or temporary tables.</li>\n<li>Each function or procedure should do one thing, do it well, and do it only - if it&#39;s doing too much, then split the logic into more than one function or procedure.</li>\n</ul>\n<h2 id=\"examples-of-clean-code\">Examples of clean code</h2>\n<p>It&#39;s easier to see how to write clean SQL code by seeing some examples.</p>\n<h3 id=\"select-statements\">Select statements</h3>\n<pre><code class=\"hljs language-sql\">select\n     rev<span class=\"hljs-selector-class\">.accountKey</span>\n    ,rev<span class=\"hljs-selector-class\">.revenueType</span>\n    ,coalesce(cus<span class=\"hljs-selector-class\">.indexedChurnDate</span>, <span class=\"hljs-number\">0</span>) - coalesce(cus<span class=\"hljs-selector-class\">.indexedGrossAddDate</span>, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span> as totalMonths\n    ,sum(coalesce(rev<span class=\"hljs-selector-class\">.revenueValue</span>, <span class=\"hljs-number\">0</span>)) as revenueValue\nfrom\n    fact<span class=\"hljs-selector-class\">.Revenue</span> rev\n        inner join\n    dim<span class=\"hljs-selector-class\">.Customer</span> cus\n            on rev<span class=\"hljs-selector-class\">.accountKey</span> = cus<span class=\"hljs-selector-class\">.accountKey</span>\nwhere\n    rev<span class=\"hljs-selector-class\">.accountKey</span> <span class=\"hljs-keyword\">in</span> (select distinct accountKey from shortLifeCustomers)\ngroup by\n     rev<span class=\"hljs-selector-class\">.accountKey</span>\n    ,rev<span class=\"hljs-selector-class\">.revenueType</span>\n    ,totalMonths</code></pre>\n<h3 id=\"ctes-common-table-expressions\">CTEs (Common Table Expressions)</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">with</span> NewProducts <span class=\"hljs-keyword\">as</span> (\n    <span class=\"hljs-keyword\">select</span>\n        productKey\n    <span class=\"hljs-keyword\">from</span>\n        fact.storeProduct\n    <span class=\"hljs-keyword\">where</span>\n        storeKey <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> storeKey <span class=\"hljs-keyword\">from</span> config.StoreFilter)\n        <span class=\"hljs-keyword\">and</span> newProductFlag = <span class=\"hljs-number\">1</span>\n),\n\nAnotherTable <span class=\"hljs-keyword\">as</span> (\n    ...\n)\n\n    <span class=\"hljs-keyword\">select</span>\n         trx.transactionKey\n        ,trx.<span class=\"hljs-built_in\">date</span>\n        ,trx.storeKey\n        ,trx.productKey\n        ,trx.netSales\n    <span class=\"hljs-keyword\">from</span>\n        fact.TransactionHistory trx\n            inner <span class=\"hljs-keyword\">join</span>\n        NewProducts np\n                <span class=\"hljs-keyword\">on</span> trx.productKey = np.productKey;</code></pre>\n<h3 id=\"create-table-statements\">Create table statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> base.Revenue (\n     contractKey <span class=\"hljs-built_in\">bigint</span>\n    ,dataDate <span class=\"hljs-built_in\">date</span>\n    ,<span class=\"hljs-keyword\">category</span> <span class=\"hljs-built_in\">text</span>\n    ,<span class=\"hljs-keyword\">value</span> <span class=\"hljs-built_in\">numeric</span>\n\n    <span class=\"hljs-keyword\">constraint</span> baseRevenuePrimaryKey primary <span class=\"hljs-keyword\">key</span> (dataDate, contractKey, <span class=\"hljs-keyword\">category</span>)\n);</code></pre>\n<h3 id=\"insert-statements\">Insert statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> dim.Customer (\n     contractKey\n    ,customerKey\n    ,customerType\n    ,activationDate\n    ,deactivationDate\n    ,billingLanguage\n    ,birthDate\n    ,tenure\n)\n    <span class=\"hljs-keyword\">select</span>\n         contract_Id <span class=\"hljs-keyword\">as</span> contractKey\n        ,customer_Id <span class=\"hljs-keyword\">as</span> customerKey\n        ,cust_type_id <span class=\"hljs-keyword\">as</span> customerType\n        ,<span class=\"hljs-keyword\">to_date</span>(activation_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> activationDate\n        ,<span class=\"hljs-keyword\">to_date</span>(deactivation_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> deactivationDate\n        ,bill_address <span class=\"hljs-keyword\">as</span> billingAddress\n        ,bill_language <span class=\"hljs-keyword\">as</span> billingLanguage\n        ,<span class=\"hljs-keyword\">to_date</span>(birth_dt, <span class=\"hljs-string\">'yyyy-mm-dd'</span>) <span class=\"hljs-keyword\">as</span> birthDate\n        ,tenure\n    <span class=\"hljs-keyword\">from</span>\n        import.Customer;</code></pre>\n<h3 id=\"update-statements\">Update statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">update</span>\n    base.Traffic\n<span class=\"hljs-keyword\">set</span>\n     dataDate = <span class=\"hljs-keyword\">to_date</span>(<span class=\"hljs-string\">'2016/11'</span>, <span class=\"hljs-string\">'YYYY-MM'</span>)\n    ,updateDate = <span class=\"hljs-keyword\">now</span>()\n<span class=\"hljs-keyword\">where</span>\n    customerKey <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> customerKey <span class=\"hljs-keyword\">from</span> base.NewCustomer);</code></pre>\n<h3 id=\"delete-statements\">Delete statements</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span>\n    base.Traffic\n<span class=\"hljs-keyword\">where</span>\n    dataDate = <span class=\"hljs-keyword\">to_date</span>(<span class=\"hljs-string\">'2013/03'</span>, <span class=\"hljs-string\">'YYYY-MM'</span>);</code></pre>\n","date":"November 19, 2016"},{"id":4,"route":"predicting-churn-without-machine-learning","title":"Predicting Churn without Machine Learning","content":"<p>So, what is <a href=\"https://en.wikipedia.org/wiki/Churn_rate\">churn</a>, and why do we care?</p>\n<p>In a business context, <strong>churn</strong> or <strong>churn rate</strong> refers to the number of customers leaving your business. Typically, this measure is tracked in subscription-based business models (like telecom operators, or most SaaS online startups), since <strong>it&#39;s cheaper to retain current customers than acquire them</strong>. The aim is to predict the point at which the customer decides to leave (before the subscription runs out) so we can try to retain the customer... perhaps by offering a discount, or other goodies. This is especially important for your high-value customers!</p>\n<p><strong>In this post I will describe a way of predicting churn based on customers&#39; inactivity profile that I&#39;ve applied in various client engagements</strong>. Without using machine learning algorithms, the model delivers an interpretable prediction of churn that gives a fairly accurate insight into the customers leaving the base. This post will not cover the implementation details - it should be straight forward to do this from the conceptual understanding taken from this post (I&#39;ve previously implemented this in SQL, Python, and SAS). Also, I won&#39;t be covering other related topics that follow from this, like calculating the value of churners to give a view of the value that is flowing out of a business.</p>\n<p>Let&#39;s start...</p>\n<h2 id=\"customer-activity\">Customer Activity</h2>\n<p>Before we start predicting churn, we need to track our customers&#39; activity over time. The objective being to know if a customer is using the service. <strong>But what does activity mean?</strong> Activity can be defined in numerous ways (below are some examples). A customer is active:</p>\n<ul>\n<li>If a customer&#39;s subscription hasn&#39;t expired</li>\n<li>When the customer performs an outgoing event in a given month (e.g. outgoing call or message in a telecom customer)</li>\n<li>If a customer has generated some revenue in a given month (non-negative <a href=\"https://en.wikipedia.org/wiki/Average_revenue_per_user\">ARPU</a>)</li>\n<li>If a customer has any <strong><em>outgoing</em></strong> or <strong><em>incoming</em></strong></li>\n<li>A combination of these but for a period of three months</li>\n</ul>\n<p>For our purposes we will be analysing customer behaviour over months</p>\n<p>Once we decide on which definition to use, we can apply it to calculate a binary value (1 or 0) for each month: <strong>If in month x, customer is active, then set activity value to one, otherwise leave as zero</strong>.</p>\n<p>I&#39;ve typically used the total monthly ARPU as the definition for activity, but this largely depends on the context of your analysis.</p>\n<h2 id=\"-and-inactivity\">... and Inactivity</h2>\n<p>Now that we have a monthly activity flag for each customer, we need to use this to build an inactivity profile. What this means is that, <strong>for each customer, we want to count the number of consecutive months of inactivity</strong>. We can visualise this as follows, where the blue table shows the activity of each customer for each month, and the green table the inactivity profile. I have chosen a one year <strong>window of analysis</strong> in this example (the total span of time we&#39;re analyzing) - I will refer to this in my explanation below:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-1.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<ul>\n<li><strong>Customer 1</strong> - this customer enters our window of analysis as active, and then becomes inactive in May (this being the first inactive month). The customer then continues being inactive till December, which is the end of our window of analysis. The inactivity profile therefore counts the number of consecutive inactive months from May till December.</li>\n<li><strong>Customer 2</strong> - like Customer 1, this one starts-off in active state. However, this customer stops being active between March and June, has a single month of activity, after which she has a couple of months of inactivity before returning to an active state for the final three months in our window of analysis. <strong>In this case our count of consecutive inactive months resets each time the customer returns to an active state</strong>. It is typical to find this &#39;on-off&#39; behaviour.</li>\n<li><strong>Customer 3</strong> - our final example customer enters our window of analysis in inactive state. This can happen either because the customer&#39;s subscription has already expired (probably best to have excluded these before starting the analysis), or the customer is inactive. As we might not have visibility before the window of analysis, if the customer has already been inactive for a few months, we won&#39;t know. Therefore, we flag these months specifically - I use the value -1 for this purpose.</li>\n</ul>\n<h2 id=\"churn-model\">Churn model</h2>\n<p>Now that we have our inactivity profile, we can use this to produce a <strong>monthly view of the number of customers for each level of consecutive inactive months within our window of analysis</strong>. We do this by aggregating, for each month, the number of customers in each level of inactivity. This is probably better explained in tabular form:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-2.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Each value represents the number of customers in each month that have been inactive for x consecutive months. So, as an example, the first highlighted value (574) is the number of customers in January that have been inactive for one month, from the 4815 customers active in December. The second highlighted value (425) is the number of customers in February that have been consecutively inactive for two months - that is, 425 from the 574 customers inactive for one month in January. <strong><em>Here, zero months inactive just represents the number of active customers in the base</em></strong>.</p>\n<p>Using this data, we can compute the <strong>percentage of customers consecutively inactive for each month in our window of analysis</strong>. See the green table below:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-3.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>The highlighted value (74%) represents the percentage of customers in February that have been inactive for two consecutive months. This is computed as follows: # of customers inactive for 2 consecutive months in Feburary divided by the # of customers inactive for 1 consecutive month in January. In this case, 425 / 574 = 74%.</p>\n<p><strong>We want to get the most representative values, so we take the average of the last four months in our window of analysis</strong>. We might not have enough data to calculate these averages (e.g. in October, November, and December) - in these cases we take the average of all the available values (the values included in the average are highlighted in red):</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-4.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<h2 id=\"churn-probabilities\">Churn probabilities</h2>\n<p>If you&#39;re still reading, congratulations! We&#39;re about to cover the most exciting part... For this, we&#39;re going to put on our statistician hats :)</p>\n<p>Let&#39;s review our final objective. This is to <strong>calculate a probability of churn for each consecutive month of inactivity</strong>. That is, if a customer has been inactive for x consecutive months, what is the chance that this customer will churn? Mathematically, we can formulate this using Bayes rule:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-5.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>However, the term below doesn&#39;t make any sense...</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-6.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>This is <strong>the probability of being inactive for x consecutive months, given that you&#39;ve churned</strong>. If you&#39;ve churned, you cannot be inactive. So for our purposes we&#39;re going to disregard this term (gasp!&nbsp;😱). This leaves us with the final version of the formula:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-7.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>So let&#39;s see what these two terms (numerator and denominator) are, and then compute them for each of the inactive months to give us the probabilities we want...</p>\n<p>First the denominator. <strong>The probability of being inactive for each of the x consecutive months</strong> are exactly the four-month average percentages we&#39;ve previously calculated:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-8.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Let&#39;s work-out the numerator, or the <strong>probability of churn</strong>, by example. So first-off, what would <code>P(churn)</code> be for customers inactive for one month? For these customers to churn, they would have to be consecutively inactive for the entire set of inactive months we&#39;re considering. In other words, the customer would have to be inactive for one month, and two months, and three months, and ... so on. Therefore, we can define the probability of churn as:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-9.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Now, in the same way, what would <code>P(churn)</code> be for customers inactive for two months? For these customers to churn, they would have to be consecutively inactive for two months, and three months, and ... so on. Therefore, we can define the probability of churn as:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-10.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>We can carry on this way for each of the inactive months:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-11.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Here, <code>n</code> is a limit on the consecutive months of inactivity where we&#39;ve noticed that the probability has stabilised. From the table above, we can see that this happens at around the seventh consecutive month, where the probability stabilises at 95-96%.</p>\n<p>For simplicity, we&#39;re going to assume that <strong>being inactive in consecutive months are independent events</strong>. This allows us to formulate the above as (see <a href=\"https://en.wikipedia.org/wiki/Independence_(probability_theory)\">here</a> why):</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-12.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Now we have worked our the numerator and denominator for each month of inactiviy we can finally calculate the churn probabilities (yay!&nbsp;🎉). We&#39;ve chosen <code>n</code> to be seven, as discussed previously.</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-13.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>This would result in the following output:</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-14.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<p>Note that the probability of churn for active customers (zero inactive months), is simply the multiplication <code>P(1) x P(2) x P(3) x ... x P(7)</code>. Here we do not divide by anything because there is no probability of inactivity when customers haven&#39;t been inactive.</p>\n<p>We can now build a <strong><em>churn curve</em></strong> for this set of customers. We can use this to decide on when it is most suitable to take specific actions on inactive customers to try and retain them, for example.</p>\n<p><img src=\"/img/predicting-churn-without-machine-learning-15.jpg\" class=\"img-fluid\" title=\"null\" alt=\"\"></p>\n<h2 id=\"other-considerations\">Other considerations</h2>\n<p>In practice, this model is run over a set of customer segments. In our example we&#39;ve just been working with a single set of customers, but it&#39;s more useful to group these according to different criteria that would make sense for your business case. For example, you can segment by value-band; that is, you segment customers by how valuable they are, and then analyse churn for each segment.</p>\n<p>Also, we&#39;ve been analysing churn in months, but it would be useful to have a more granular view, weekly or even daily.</p>\n","date":"April 16, 2017"}];
  
  module.exports = {
      blogPosts,
  };
  